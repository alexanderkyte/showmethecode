derivDefinition = """
def derivativeWrapper(f, precision=0.0000001):
# the derivative
    def derivative(x):
        return (f(x+precision) - f(x))/(precision)
    return derivative
"""

integralDefinition = """
def integraliWrapper(f, lower, upper):
    # This is the simpson's approximation. n is the number of subintervals. It can be any even number
    n = 1000000
    h = (upper-lower)/n
    twos = list()
    fours = list()
    for number in range(n):
        if number % 2 == 1:
            twos.append(lower+(number*h))
        elif number % 2 == 0:
            fours.append(lower+(number*h))
        else:
            print("Something went horribly wrong. Run away!")
    sum = f(lower) + f(upper)
    for number in twos:
        sum += 2 * number
    for number in fours:
        sum += 4 * number
    sum = sum * (h/3)
    return sum
"""

#commented out still
"""
def sequence(f, start=0):
    while True:
        yield f(start)
        start += 1

def series(f, start=0):
   #For this limited defintion, a series is a summation from 0 to infinity of a geomatric sequence generated by a function
   a = f(0)
   r = f(0) / f(1)
   return a / (1-r)

### Perhaps just parse the summation into a for i in range loop, for nested summations.
"""


summationDefinition = """
def summation(f, start, stop):
    sum = 0
    for i in range(start-stop):
        sum += f(i)
    return sum
"""


